# Operating-Platforms--The-Gaming-Room
Operating Platforms- The Gaming Room

The client for this was The Gaming Room, and the requested software was a new web-based, real-time guessing game titled "Draw it or Lose it." The core requirement was to create a game that supports multiple teams, features one-minute rounds, and art that is revealed progressively over time, with a 15-second bonus round at the end. The software needed to be able to handle unique games, teams, player identifiers, concurrent players, scalability, and maintain this across multiple operating systems and platforms.

The aspects I performed well in were systematic mapping and requirements. I successfully translated the high-level business needs into specific technical decisions. The evaluation section was well done; however, I could have been more specific and elaborate in several cases under the recommendations. This should have been improved to be more detailed for the customer in question, providing them with all the necessary information.

The process of developing this documentation helps prepare me to write the code in many ways. Specifically, we addressed scalability and security before even beginning to write the code. This can help force alignment of intent and implementation before code is written. This will help save me time and effort down the road if I already have a basic idea of what route to take, such as using websockets and a NoSQL database, rather than having to figure it out later.

If I were to revise and improve anything, it again would be the recommendation section as a whole. I did fix a few things before uploading to this GitHub; however, I could have been much more elaborate in section cases for the client. For example, I did not cover enough information on storage management and operating system architecture. 

The ways I took into account the user's needs were by implementing stability, real-time functionality, and the route of access. This was designed to provide a real-time, stable gaming experience accessible across different teams and devices, with no lag, access issues, or stability issues, which can ultimately lead to a failed project, regardless of the code's quality. The user's needs are paramount because if they cannot be met, the product will not succeed, regardless of how well-written the code is. A positive user experience is everything when it comes to developing a project; otherwise, it will likely not be used. There are a few cases where this isn't the case, and they usually hold a monopoly on what they do well to avoid it.

When developing this, I employed a requirement-driven design strategy, which involves considering the analysis of what was needed, followed by determining how it would be implemented, and then applying it in action through conceptual design, pattern application, and platform evaluation. In the future, for a similar approach, I will provide even more UML diagrams to support the strategy and suggestions I have given to help establish my point, and also to prepare myself for future endeavors.


